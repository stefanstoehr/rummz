{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh19980\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 // flat shape\
\
geometry = new THREE.ShapeGeometry( shape );\
\
mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( \{ color: color, side: THREE.DoubleSide \} ) );\
mesh.position.set( x, y, z - 125 );\
mesh.rotation.set( rx, ry, rz );\
mesh.scale.set( s, s, s );\
group.add( mesh );\
\
/////////////////////////////////////TEST3\
\
// CALIFORNIA\
\
const californiaPts = [];\
\
californiaPts.push( new THREE.Vector2( -10, 10 ) );\
californiaPts.push( new THREE.Vector2( -10, -10 ) );\
californiaPts.push( new THREE.Vector2( 0, 0 ) );\
californiaPts.push( new THREE.Vector2( 0, 1.25 ) );\
californiaPts.push( new THREE.Vector2( -5.833333333333333, 10 ) );\
\
const californiaShape = new THREE.Shape( californiaPts );\
const brownGeometry = new THREE.ShapeGeometry( californiaShape );\
const brownMesh = new THREE.Mesh( brownGeometry, new THREE.MeshPhongMaterial( \{ color: "brown", side: THREE.DoubleSide \} ) );\
\
scene.add(brownMesh)\
\
////////////////////////////////////TEST3\
\
\
diagram.cells\
\
[0] va1\
[1] vb1\
\
[2] va2\
[3] vb2\
\
Ist va1 und vb1 in der richtigen Reihenfolge?\
\
Wenn va2 == vb1, dann ja!\
L\'f6sche va2 & mache [2] vb2\
\
Wenn va2 == va1, dann nein!\
Array-Reihenfolge \'e4ndern in: [0] vb1 & [1] va1\
L\'f6sche va2 & mache [2] vb2\
\
\
Object Array []\
\
var takenVertices = [];\
\
[\
\{\
  "x": -30.621816613898222,\
  "y": -39.42013654333509\
\},\
\{\
  "x": 25.232464323778814,\
  "y": 79.33962579827039\
\}, \
\{\
  "x": 80.69118963826256,\
  "y": 26.34607048183217\
\},\
\
]\
\
Speichere alle va und vb getrennt nach Zelle\
\
cellsOriginArray = [];\
\
[ \{\}, \{\}, \{\}, \{\} ]\
[ [], [], [], [] ]\
\
[ \{ [0, 0], [-10, -10], [0, 0], [10, -10] , [10, -10], [-10, -10] \}, \{\}, \{\}, \{\} ]\
[ [ [0, 0], [-10, -10], [0, 0], [10, -10] , [10, -10], [-10, -10] ], [], [], [] ]\
[ [ [ [ 0, 0 ], [ -10, -10 ] ], [ [ 0, 0 ], [ 10, -10 ] ], [ [ 10, -10 ], [ -10, -10 ] ] ], [], [], [] ]\
\
\{ "va": 0,\
  "vb": 0\
\},\
\{ "va": -10,\
  "vb": -10\
\},\
\{ "va": 0,\
  "vb": 0\
\},\
\{ "va": 10,\
  "vb": -10\
\},\
\{ "va": 10,\
  "vb": -10\
\},\
\{ "va": -10,\
  "vb": -10\
\}\
\
\
Sortierung Paarweise und Speichere in neuem Array cellsNewArray = [];\
\
cellsArray[0].[2] == cellsArray[0].[0]\
 \
\
\
Gehe jede Zelle und darin alle Kantenvertices durch, starte mit der ersten Zelle:\
i = 0, i < diagram.cells.length, i++\
\
sammle chronologisch alle Vertices je Objekt aus Array diagram.cells an der Stelle diagram.cells[i]\
j = 0, j < diagram.cells[i].halfedges.length, j++\
}