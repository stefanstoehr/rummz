<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>P4</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/voronoi@1.0.0/rhill-voronoi-core.min.js"></script>
    <script>

        let camera, controls, scene, renderer;

        init();

        function init() {

            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setAnimationLoop( animate );
            document.body.appendChild( renderer.domElement );

            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.set( 0, 0, 0 );
            const axesHelper = new THREE.AxesHelper( 5 ); scene.add( axesHelper );
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            var light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.setScalar(100);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            
            // die x- und y-Punkte kommen dann von den Markern
            const points = [];
            points.push( new THREE.Vector3( - 10, 0, 0 ) );
            points.push( new THREE.Vector3( 0, 10, 0 ) );
            points.push( new THREE.Vector3( 10, 0, 0 ) );
            points.push( new THREE.Vector3( 5, -5, 0 ) );
            
            const geom = new THREE.BufferGeometry().setFromPoints( points );
            const material = new THREE.PointsMaterial( { color: 0x99ccff, size: 1 } );
            const pointcloud = new THREE.Points( geom, material );
            scene.add( pointcloud );

            //VORONOI//
            var radius = 15;
            var voronoi = new Voronoi();
            var bbox = {xl: -radius, xr: radius, yt: -radius, yb: radius};
            var diagram = voronoi.compute(points, bbox);
            console.log(diagram);

            var voronoiPoints = diagram.vertices;
            var voronoiPointsGeom = new THREE.BufferGeometry().setFromPoints(voronoiPoints);
            var voronoiPointsMat = new THREE.PointsMaterial({color: "magenta", size: 1});
            var voronoiPoints = new THREE.Points(voronoiPointsGeom, voronoiPointsMat);
            scene.add(voronoiPoints);

            var voronoiLinesPoints = [];
            var voronoiLinesColors = [];
            diagram.edges.forEach(ed => {
            if (Math.max(Math.hypot(ed.va.x, ed.va.y), Math.hypot(ed.vb.x, ed.vb.y)) < radius){
                voronoiLinesPoints.push(ed.va.x, ed.va.y, 0, ed.vb.x, ed.vb.y, 0, ed.va.x, ed.va.y, 10, ed.vb.x, ed.vb.y, 10);
                voronoiLinesColors.push(1, 1, 0, 1, 1, 0, 0, 0.25, 0.25, 0, 0.25, 0.25);
            }
            });
            var voronoiLinesGeom = new THREE.BufferGeometry();
            voronoiLinesGeom.setAttribute("position", new THREE.Float32BufferAttribute(voronoiLinesPoints, 3));
            voronoiLinesGeom.setAttribute("color", new THREE.Float32BufferAttribute(voronoiLinesColors, 3));
            var voronoiLinesMat = new THREE.LineBasicMaterial({vertexColors: true});
            var voronoiLines = new THREE.LineSegments(voronoiLinesGeom, voronoiLinesMat);
            scene.add(voronoiLines);

            var voronoiMeshPoints = [];
            var voronoiMeshIndex = [];
            var vIdx = 0;
            diagram.edges.forEach(ed => {
            if (Math.max(Math.hypot(ed.va.x, ed.va.y), Math.hypot(ed.vb.x, ed.vb.y)) < radius){
                voronoiMeshPoints.push(
                ed.va.x, ed.va.y, 0, ed.vb.x, ed.vb.y, 0, ed.va.x, ed.va.y, 10, ed.vb.x, ed.vb.y, 10
                );
                voronoiMeshIndex.push(vIdx + 2, vIdx + 0, vIdx + 3, vIdx + 0, vIdx + 1, vIdx + 3);
                vIdx += 4;
            }
            })
            var voronoiMeshGeom = new THREE.BufferGeometry();
            voronoiMeshGeom.setAttribute("position", new THREE.Float32BufferAttribute(voronoiMeshPoints, 3));
            voronoiMeshGeom.setIndex(voronoiMeshIndex);
            voronoiMeshGeom.computeVertexNormals();
            let voronoiMeshMat = new THREE.MeshLambertMaterial({color: 0x448888, side: THREE.DoubleSide});
            let voronoiMesh = new THREE.Mesh(voronoiMeshGeom, voronoiMeshMat);
            scene.add(voronoiMesh);
            //VORONOI//


            //DELUNATOR//
            // triangulate x, z
            var indexDelaunay = Delaunator.from(
                points.map(v => {
                    return [v.x, v.y];
                })
            );
            console.log(indexDelaunay);
            
            var meshIndex = []; // delaunay index => three.js index
            for (let i = 0; i < indexDelaunay.triangles.length; i++){
            meshIndex.push(indexDelaunay.triangles[i]);
            }

            geom.setIndex(meshIndex); // add three.js index to the existing geometry
            geom.computeVertexNormals();
            var mesh = new THREE.Mesh(
            geom, // re-use the existing geometry
            new THREE.MeshLambertMaterial({ color: 0x99ccff, wireframe: true })
            );
            scene.add(mesh);
            //DELUNATOR//

            //B-BOX//
            const box = new THREE.BoxHelper( mesh, 0xffff00 ); scene.add( box );
            //B-BOX//

            camera.position.z = 25;

            window.addEventListener( 'resize', onWindowResize );

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {

            controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

            render();

        }

        function render() {

            renderer.render( scene, camera );

        }

    </script>
</body>
</html>
