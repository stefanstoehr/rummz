<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>3D Volumenmodell - alle Schichten (robust)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{margin:0;height:100%;overflow:hidden;font-family:Arial,Helvetica,sans-serif}
  #ui { position: absolute; left:10px; top:10px; z-index:3;
         background: rgba(255,255,255,0.9); padding:8px; border-radius:6px; }
  #legend { margin-top:6px; max-height:200px; overflow:auto; font-size:13px; }
  #note { font-size:12px; color:#333; margin-top:6px; }
</style>
</head>
<body>
<div id="ui">
  <div><strong>3D Schichtenmodell (Demo)</strong></div>
  <div id="note">Vertikale Überhöhung: <span id="veVal">6</span>×</div>
  <input id="ve" type="range" min="1" max="20" value="6" step="1" />
  <div id="legend"></div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/",
    "d3-delaunay": "https://cdn.jsdelivr.net/npm/d3-delaunay@6.0.2/+esm"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { Delaunay } from 'd3-delaunay';

// ======================
// === Deine Daten ===
// ======================
const boreholes = [
  {
    id: "BK1",
    coords: {lat: 51.76699001900172, lng: 14.321020555443924},
    nhn: 60,
    layers: [
      {name:"Beton", height:20, color:"#6c5eb0"},
      {name:"Kies", height:30, color:"#f2a807"},
      {name:"Sand", height:50, color:"#ffff00"},
      {name:"Grundwasser", height:15, color:"#0080ff"}
    ]
  },
  {
    id: "BK2",
    coords: {lat: 51.76758227275856, lng: 14.320126696295224},
    nhn: 60.5,
    layers: [
      {name:"Beton", height:15, color:"#6c5eb0"},
      {name:"Sand", height:45, color:"#ffff00"},
      {name:"Grundwasser", height:12, color:"#0080ff"},
      {name:"Erde", height:35, color:"#997b0f"}
    ]
  },
  {
    id: "BK3",
    coords: {lat: 51.7663472955396, lng: 14.32011381376906},
    nhn: 61,
    layers: [
      {name:"Beton", height:10, color:"#6c5eb0"},
      {name:"Kies", height:34, color:"#f2a807"},
      {name:"Erde", height:23, color:"#997b0f"}
    ]
  }
];

// ======================
// === Einstellungen ===
// ======================
let verticalExaggeration = Number(document.getElementById('ve').value); // veränderbar per Slider

// Re-projection: kleine equirect. Näherung (lokal)
const refLat = boreholes.reduce((s,b)=>s+b.coords.lat,0)/boreholes.length;
const refLon = boreholes.reduce((s,b)=>s+b.coords.lng,0)/boreholes.length;
const mPerDegLat = 111320;
const mPerDegLon = 111320 * Math.cos(refLat*Math.PI/180);
function latLonToXZ(lat, lon){
  return { x: (lon-refLon)*mPerDegLon, z: (lat-refLat)*mPerDegLat };
}

// Layer Tops & Bottoms (rechne heights in Meter: cm -> m)
function computeLayerTopsAndBottoms(bh){
  let currentDepth = 0;
  return bh.layers.map(layer=>{
    const top = bh.nhn - currentDepth;
    const bottom = top - (layer.height / 100.0);
    currentDepth += (layer.height / 100.0);
    return { name: layer.name, color: layer.color, top, bottom };
  });
}

// Convex hull (Monotone chain) - liefert Indizes in original points array
function convexHullIndices(points2D){
  const n = points2D.length;
  if(n < 3) return [...Array(n).keys()];
  const pts = points2D.map((p,i)=>({x:p[0], y:p[1], i}));
  pts.sort((a,b)=> a.x === b.x ? a.y - b.y : a.x - b.x);
  const cross = (o,a,b) => (a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x);
  const lower = [];
  for(const p of pts){
    while(lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
    lower.push(p);
  }
  const upper = [];
  for(let i = pts.length -1; i >=0; i--){
    const p = pts[i];
    while(upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
    upper.push(p);
  }
  // concat without last points (they are duplicates)
  const hull = lower.slice(0, lower.length-1).concat(upper.slice(0, upper.length-1));
  return hull.map(h => h.i);
}

// ======================
// === Three.js Szene ===
// ======================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf4f6f8);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
camera.position.set(120, 120, 120);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, -2, 0);
controls.update();

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 0.9);
dl.position.set(200,300,100);
scene.add(dl);

scene.add(new THREE.GridHelper(200, 20));
scene.add(new THREE.AxesHelper(12));

// Legend container
const legendDiv = document.getElementById('legend');

// Utility to create surface mesh from triangle indices and points
function buildSurfaceMesh(points3, triangles, color, opacity=0.7){
  const verts = [];
  for(let i=0;i<triangles.length;i+=3){
    const ai = triangles[i], bi = triangles[i+1], ci = triangles[i+2];
    const a = points3[ai], b = points3[bi], c = points3[ci];
    // push as x,y,z (Three.js)
    verts.push(a[0], a[1]*verticalExaggeration, a[2]);
    verts.push(b[0], b[1]*verticalExaggeration, b[2]);
    verts.push(c[0], c[1]*verticalExaggeration, c[2]);
  }
  const g = new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
  g.computeVertexNormals();
  const m = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide, transparent:true, opacity });
  return new THREE.Mesh(g, m);
}

// Build sides from hull indices
function buildSidesFromHull(topPoints, botPoints, hullIdx, color, opacity=0.7){
  const verts = [];
  const n = hullIdx.length;
  for(let i=0;i<n;i++){
    const i1 = hullIdx[i];
    const i2 = hullIdx[(i+1)%n];
    const t1 = topPoints[i1], t2 = topPoints[i2];
    const b1 = botPoints[i1], b2 = botPoints[i2];
    // two triangles (t1,t2,b1) and (t2,b2,b1)
    verts.push(t1[0], t1[1]*verticalExaggeration, t1[2]);
    verts.push(t2[0], t2[1]*verticalExaggeration, t2[2]);
    verts.push(b1[0], b1[1]*verticalExaggeration, b1[2]);

    verts.push(t2[0], t2[1]*verticalExaggeration, t2[2]);
    verts.push(b2[0], b2[1]*verticalExaggeration, b2[2]);
    verts.push(b1[0], b1[1]*verticalExaggeration, b1[2]);
  }
  const g = new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
  g.computeVertexNormals();
  const m = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide, transparent:true, opacity });
  return new THREE.Mesh(g, m);
}

// Build rectangular box for 2-point case
function buildBoxBetweenTwoPoints(pTopA, pBotA, pTopB, pBotB, color){
  // coordinates: [x, yHeight(m), z] where yHeight is elevation in m (not scaled)
  const centerX = (pTopA[0] + pTopB[0]) / 2;
  const centerZ = (pTopA[2] + pTopB[2]) / 2;
  const avgTop = (pTopA[1] + pTopB[1]) / 2;
  const avgBot = (pBotA[1] + pBotB[1]) / 2;
  const height = Math.max(0.01, avgTop - avgBot); // m
  const dx = pTopB[0] - pTopA[0];
  const dz = pTopB[2] - pTopA[2];
  const length = Math.hypot(dx, dz);
  const width = Math.max(1, length * 0.4); // make visible
  const boxGeo = new THREE.BoxGeometry(length, height * verticalExaggeration, width);
  const mat = new THREE.MeshStandardMaterial({ color, transparent:true, opacity:0.7 });
  const mesh = new THREE.Mesh(boxGeo, mat);
  // position
  mesh.position.set(centerX, (avgTop + avgBot)/2 * verticalExaggeration, centerZ);
  // rotate around Y to align with line
  const theta = Math.atan2(dz, dx);
  mesh.rotation.y = -theta; // choose sign so box aligns
  return mesh;
}

// Build cylinder for 1-point case
function buildCylinderAtPoint(topP, botP, color){
  const avgTop = topP[1], avgBot = botP[1];
  const height = Math.max(0.01, avgTop - avgBot);
  const radius = 2.0; // meters
  const geo = new THREE.CylinderGeometry(radius, radius, height * verticalExaggeration, 20);
  const mat = new THREE.MeshStandardMaterial({ color, transparent:true, opacity:0.8 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(topP[0], (avgTop + avgBot)/2 * verticalExaggeration, topP[2]);
  return mesh;
}

// ======================
// === Modell bauen ===
// ======================
// Sammle alle Layer-Namen
const allLayerNames = [...new Set(boreholes.flatMap(bh => bh.layers.map(l => l.name)))];

// Build legend
legendDiv.innerHTML = '<strong>Legende</strong><div id="legItems"></div>';
const legItems = document.getElementById('legItems');

// For each layer, collect top/bottoms across boreholes
allLayerNames.forEach(layerName => {
  const topPoints = []; // [x, elevation_m, z]
  const botPoints = [];
  const coords2D = [];
  let color = '#cccccc';
  boreholes.forEach(bh => {
    const layers = computeLayerTopsAndBottoms(bh);
    const L = layers.find(ll => ll.name === layerName);
    if(L){
      const p2 = latLonToXZ(bh.coords.lat, bh.coords.lng);
      topPoints.push([p2.x, L.top, p2.z]);
      botPoints.push([p2.x, L.bottom, p2.z]);
      coords2D.push([p2.x, p2.z]);
      color = L.color || color;
    }
  });

  // add legend entry
  const entry = document.createElement('div');
  entry.innerHTML = `<span style="display:inline-block;width:14px;height:12px;background:${color};margin-right:6px;border:1px solid #666"></span>${layerName} — Punkte: ${topPoints.length}`;
  legItems.appendChild(entry);

  if(topPoints.length >= 3){
    // triangulate (2D) using Delaunay and build top+bottom surfaces
    const delaunay = Delaunay.from(coords2D);
    const triangles = delaunay.triangles;

    // make Meshes
    const topMesh = buildSurfaceMesh(topPoints, triangles, color, 0.7);
    const botMesh = buildSurfaceMesh(botPoints, triangles, color, 0.7);
    scene.add(topMesh);
    scene.add(botMesh);

    // sides from convex hull — robust and visually clean
    const hullIdx = convexHullIndices(coords2D);
    if(hullIdx.length >= 2){
      const sideMesh = buildSidesFromHull(topPoints, botPoints, hullIdx, color, 0.7);
      scene.add(sideMesh);
    }
  } else if (topPoints.length === 2){
    const box = buildBoxBetweenTwoPoints(topPoints[0], botPoints[0], topPoints[1], botPoints[1], color);
    scene.add(box);
  } else if (topPoints.length === 1){
    const cyl = buildCylinderAtPoint(topPoints[0], botPoints[0], color);
    scene.add(cyl);
  } else {
    // keine Punkte für diese Schicht - überspringen
  }
});

// ======================
// === Interaktion VE ===
// ======================
const veSlider = document.getElementById('ve');
const veVal = document.getElementById('veVal');
veSlider.addEventListener('input', ()=>{
  verticalExaggeration = Number(veSlider.value);
  veVal.textContent = verticalExaggeration;
  // einfache Strategie: reload die Seite neu bauen (einfach und robust)
  // hier: reload script — quick way to rebuild with new VE
  // (alternativ könnte man die Geometrien neu erstellen; reload ist ok für Demo)
  // To avoid hard reload, we re-run by clearing scene and re-invoking build routine
  // Simpler: full page reload so the code re-executes with new VE:
  window.location.reload();
});

// ======================
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

// Resize
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

</script>
</body>
</html>
