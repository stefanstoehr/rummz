<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P13</title>
    <style>
        html, body {
          height: 100%;
          margin: 0;
          overflow: hidden;
          font-family: Verdana;
        }
        canvas {
          width: 100%;
          height: 100%;
          display: block;
        }
    </style>
</head>
<body>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/voronoi@1.0.0/rhill-voronoi-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.3/dat.gui.min.js"></script>
  <div id="canvas"></div>
  
  <script>

    //SCENE-BASICS
    console.clear();
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, -50, 25);
    camera.up.set(0, 0, 1);
    const axesHelper = new THREE.AxesHelper( 5 );
    scene.add( axesHelper );
    var renderer = new THREE.WebGLRenderer({ antialias: true });
    var canvas = renderer.domElement;
    document.body.appendChild(canvas);
    var controls = new THREE.OrbitControls( camera, canvas );
    controls.autoRotate = true;
    const lights = [];
	  lights[ 0 ] = new THREE.DirectionalLight( 0xffffff, 1 );
	  lights[ 1 ] = new THREE.DirectionalLight( 0xffffff, 1 );
	  lights[ 2 ] = new THREE.DirectionalLight( 0xffffff, 1 );
	  lights[ 0 ].position.set( 0, 200, 100 );
	  lights[ 1 ].position.set( 100, 200, 100 );
	  lights[ 2 ].position.set( - 100, - 200, - 100 );
	  scene.add( lights[ 0 ] );
	  scene.add( lights[ 1 ] );
	  scene.add( lights[ 2 ] );

    //GEOMETRY CONSTRUCTION WITH EXTRUDING
    //DOWN POLYGON [0]
    const downPolygonPoints = [];
    downPolygonPoints.push( new THREE.Vector2( 10, -10 ) );
    downPolygonPoints.push( new THREE.Vector2( 0, 0 ) );
    downPolygonPoints.push( new THREE.Vector2( -10, -10 ) );
    const downPolygonShape = new THREE.Shape( downPolygonPoints );
    const downPolygonExtrude = { steps: 1, depth: 2, bevelEnabled: false };
    const downPolygonGeometry = new THREE.ExtrudeGeometry( downPolygonShape, downPolygonExtrude );
    const downPolygonMesh = new THREE.Mesh( downPolygonGeometry, new THREE.MeshPhongMaterial( { color: "cyan" } ) );
    scene.add(downPolygonMesh)
    // SCHICHTBILDUNG: MESH KOPIEREN UND DEPTH- UND FARB-ATTRIBUTE VERÄNDERN
    var newDown = downPolygonMesh.clone();
    newDown.position.setZ(-2);
    newDown.material = newDown.material.clone();
    newDown.material.color.setColorName("darkblue");
    scene.add(newDown);

    //LEFT POLYGON [1]
    const leftPolygonPoints = [];
    leftPolygonPoints.push( new THREE.Vector2( -10, 10 ) );
    leftPolygonPoints.push( new THREE.Vector2( -10, -10 ) );
    leftPolygonPoints.push( new THREE.Vector2( 0, 0 ) );
    leftPolygonPoints.push( new THREE.Vector2( 0, 1.25 ) );
    leftPolygonPoints.push( new THREE.Vector2( -5.833333333333333, 10 ) );
    const leftPolygonShape = new THREE.Shape( leftPolygonPoints );
    const leftPolygonExtrude = { steps: 1, depth: 5, bevelEnabled: false };
    const leftPolygonGeometry = new THREE.ExtrudeGeometry( leftPolygonShape, leftPolygonExtrude );
    const leftPolygonMesh = new THREE.Mesh( leftPolygonGeometry, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );
    scene.add(leftPolygonMesh)
    // SCHICHTBILDUNG: MESH KOPIEREN UND DEPTH- UND FARB-ATTRIBUTE VERÄNDERN
    var newLeft = leftPolygonMesh.clone();
    newLeft.position.setZ(-5);
    newLeft.material = newLeft.material.clone();
    newLeft.material.color.setColorName("darkgreen");
    scene.add(newLeft);
    
    //RIGHT POLYGON [2]
    const rightPolygonPoints = [];
    rightPolygonPoints.push( new THREE.Vector2( 10, -10 ) );
    rightPolygonPoints.push( new THREE.Vector2( 10, 6.25 ) );
    rightPolygonPoints.push( new THREE.Vector2( 0, 1.25 ) );
    rightPolygonPoints.push( new THREE.Vector2( 0, 0 ) );
    const rightPolygonShape = new THREE.Shape( rightPolygonPoints );
    const rightPolygonExtrude = { steps: 1, depth: 3, bevelEnabled: false };
    const rightPolygonGeometry = new THREE.ExtrudeGeometry( rightPolygonShape, rightPolygonExtrude );
    const rightPolygonMesh = new THREE.Mesh( rightPolygonGeometry, new THREE.MeshPhongMaterial( { color: "violet" } ) );
    scene.add(rightPolygonMesh);
    // SCHICHTBILDUNG: MESH KOPIEREN UND DEPTH- UND FARB-ATTRIBUTE VERÄNDERN
    var newRight = rightPolygonMesh.clone();
    newRight.position.setZ(-3);
    newRight.material = newRight.material.clone();
    newRight.material.color.setColorName("darkviolet");
    scene.add(newRight);

    //TOP POLYGON [3]
    const topPolygonPoints = [];
    topPolygonPoints.push( new THREE.Vector2( 10, 10 ) );
    topPolygonPoints.push( new THREE.Vector2( -5.833333333333333, 10 ) );
    topPolygonPoints.push( new THREE.Vector2( 0, 1.25 ) );
    topPolygonPoints.push( new THREE.Vector2( 10, 6.25 ) );
    const topPolygonShape = new THREE.Shape( topPolygonPoints );
    const topPolygonExtrude = { steps: 1, depth: 7, bevelEnabled: false };
    const topPolygonGeometry = new THREE.ExtrudeGeometry( topPolygonShape, topPolygonExtrude );
    const topPolygonMesh = new THREE.Mesh( topPolygonGeometry, new THREE.MeshPhongMaterial( { color: "tomato" } ) );
    scene.add(topPolygonMesh);
    // SCHICHTBILDUNG: MESH KOPIEREN UND DEPTH- UND FARB-ATTRIBUTE VERÄNDERN
    var newTop = topPolygonMesh.clone();
    newTop.position.setZ(-7);
    newTop.material = newTop.material.clone();
    newTop.material.color.setColorName("red");
    scene.add(newTop);
    
    //POINT-INPUT FROM MAP
    var points2d = [];
    points2d.push( new THREE.Vector2( - 10, 0, ) );
    points2d.push( new THREE.Vector2( 0, -10, ) );
    points2d.push( new THREE.Vector2( 10, 0, ) );
    points2d.push( new THREE.Vector2( 5, 10, ) );

    //CREATING VISIBLE POINT-GEOMETRY FROM POINTS
    var geom = new THREE.BufferGeometry().setFromPoints(points2d);
    var cloud = new THREE.Points( geom, new THREE.PointsMaterial({ color: "cyan", size: 2 }));
    scene.add(cloud);

    //DELUNATOR//           
    var indexDelaunay = Delaunator.from(
        points2d.map(v => {
            return [v.x, v.y];
        })
    );
    var meshIndex = []; // delaunay index => three.js index
    for (let i = 0; i < indexDelaunay.triangles.length; i++){
        meshIndex.push(indexDelaunay.triangles[i]);
    };
    geom.setIndex(meshIndex); // add three.js index to the existing geometry
    geom.computeVertexNormals();
    var mesh = new THREE.Mesh(
        geom, // re-use the existing geometry
        new THREE.MeshLambertMaterial({ color: 0x99ccff, wireframe: true })
    );
    scene.add(mesh);

    //BOUNDING-BOX-HELPER
    const boxbox = new THREE.BoxHelper( mesh, 0xffff00 ); scene.add( boxbox );

    //CALCULATING VORONOI
    var voronoi = new Voronoi();
    var bbox = {xl: -10, xr: 10, yt: -10, yb: 10}; // Max.-/Min.-Search
    var diagram = voronoi.compute(points2d, bbox);
    
    
    //EXTRACTION OF VERTICES FOR GEOMETRY CONSTRUCTION
    console.log(diagram.cells);
    //[0]
    console.log("[0]:")
    console.log(diagram.cells[0].halfedges[2].getStartpoint());
    console.log(diagram.cells[0].halfedges[1].getStartpoint());
    console.log(diagram.cells[0].halfedges[0].getStartpoint());
    //[1]
    console.log("[1]:")
    console.log(diagram.cells[1].halfedges[4].getStartpoint());
    console.log(diagram.cells[1].halfedges[3].getStartpoint());
    console.log(diagram.cells[1].halfedges[2].getStartpoint());
    console.log(diagram.cells[1].halfedges[1].getStartpoint());
    console.log(diagram.cells[1].halfedges[0].getStartpoint());
    //[2]
    console.log("[2]:")
    console.log(diagram.cells[2].halfedges[3].getStartpoint());
    console.log(diagram.cells[2].halfedges[2].getStartpoint());
    console.log(diagram.cells[2].halfedges[1].getStartpoint());
    console.log(diagram.cells[2].halfedges[0].getStartpoint());
    //[3]
    console.log("[3]:")
    console.log(diagram.cells[3].halfedges[3].getStartpoint());
    console.log(diagram.cells[3].halfedges[2].getStartpoint());
    console.log(diagram.cells[3].halfedges[1].getStartpoint());
    console.log(diagram.cells[3].halfedges[0].getStartpoint());
    //END

    //CREATING VISIBLE THREE.JS-POINT-GEOMETRY FROM VORONOIS-POINTS
    var voronoiPoints = diagram.vertices;
    var voronoiPointsGeom = new THREE.BufferGeometry().setFromPoints(voronoiPoints);
    var voronoiPointsMat = new THREE.PointsMaterial({color: "magenta", size: 2});
    var voronoiPoints = new THREE.Points(voronoiPointsGeom, voronoiPointsMat);
    scene.add(voronoiPoints);

    //CREATING THREE.JS-LINES FROM VORONOIS
    var voronoiLinesPoints = [];
    diagram.edges.forEach(ed => {
      voronoiLinesPoints.push(ed.va.x, ed.va.y, 0, ed.vb.x, ed.vb.y, 0)
    });
    var voronoiLinesGeom = new THREE.BufferGeometry();
    voronoiLinesGeom.setAttribute("position", new THREE.Float32BufferAttribute(voronoiLinesPoints, 3));
    var voronoiLinesMat = new THREE.LineBasicMaterial({color: "green"});
    var voronoiLines = new THREE.LineSegments(voronoiLinesGeom, voronoiLinesMat);
    scene.add(voronoiLines);

    //CREATING GUI
    var gui = new dat.GUI({width: 400});
    gui.add(axesHelper, "visible").name("axes helper");
    gui.add(cloud, "visible").name("base points");
    gui.add(boxbox, "visible").name("bounding box");
    gui.add(mesh, "visible").name("delauny triangles");
    gui.add(voronoiPoints, "visible").name("voronoi points");
    gui.add(voronoiLines, "visible").name("voronoi lines");
    gui.add(downPolygonMesh, "visible").name("cyan volume");
    gui.add(leftPolygonMesh, "visible").name("green volume");
    gui.add(topPolygonMesh, "visible").name("yellow volume");
    gui.add(rightPolygonMesh, "visible").name("magenta volume");

    //THREE.JS BASIC VISUAL FINISHING
    render();

    function resize(renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render() {
      if (resize(renderer)) {
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }
      renderer.render(scene, camera);
      requestAnimationFrame(render);
      controls.update();
    }
    
</script>
</body>
</html>
