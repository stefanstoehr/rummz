<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>P3</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
    <script>

        let camera, controls, scene, renderer;

        init();

        function init() {

            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setAnimationLoop( animate );
            document.body.appendChild( renderer.domElement );

            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.set( 0, 0, 0 );
            const axesHelper = new THREE.AxesHelper( 5 ); scene.add( axesHelper );
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            var light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.setScalar(100);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            
            // die x- und y-Punkte kommen dann von den Markern
            const points = [];
            points.push( new THREE.Vector3( - 10, 0, 0 ) );
            points.push( new THREE.Vector3( 0, 10, 0 ) );
            points.push( new THREE.Vector3( 10, 0, 0 ) );
            points.push( new THREE.Vector3( 5, -5, 0 ) );
            
            const geom = new THREE.BufferGeometry().setFromPoints( points );
            const material = new THREE.PointsMaterial( { color: 0x99ccff, size: 1 } );
            const pointcloud = new THREE.Points( geom, material );
            scene.add( pointcloud );
            
            /**/
            // triangulate x, z
            var indexDelaunay = Delaunator.from(
                points.map(v => {
                    return [v.x, v.y];
                })
            );
            console.log(indexDelaunay);
            
            var meshIndex = []; // delaunay index => three.js index
            for (let i = 0; i < indexDelaunay.triangles.length; i++){
            meshIndex.push(indexDelaunay.triangles[i]);
            }

            geom.setIndex(meshIndex); // add three.js index to the existing geometry
            geom.computeVertexNormals();
            var mesh = new THREE.Mesh(
            geom, // re-use the existing geometry
            new THREE.MeshLambertMaterial({ color: 0x99ccff, wireframe: true })
            );
            scene.add(mesh);
            /**/


            camera.position.z = 25;

            window.addEventListener( 'resize', onWindowResize );

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function animate() {

            controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

            render();

        }

        function render() {

            renderer.render( scene, camera );

        }

    </script>
</body>
</html>
