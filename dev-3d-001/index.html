<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>3D Bohrkern Schichten - Demo</title>
<style>
  html,body{height:100%;margin:0}
  body{font-family:Arial,Helvetica,sans-serif;overflow:hidden}
  #info{position:absolute;left:10px;top:10px;background:rgba(255,255,255,0.85);padding:8px;border-radius:4px;z-index:2}
</style>
</head>
<body>
<div id="info">Demo: mehrere Bohrungen (EPSG:4326 → lokale Meter). Klick auf eine Schicht zeigt Mächtigkeit.</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// Scene + renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xeaf0f6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Camera
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);
camera.position.set(200, 200, 200);

// Lights
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(200,300,100);
scene.add(dir);
scene.add(new THREE.AmbientLight(0xffffff,0.4));

// Ground grid (XZ plane) -- Three.js uses Y up
const grid = new THREE.GridHelper(1000, 50, 0x999999, 0xdddddd);
scene.add(grid);

// Example borehole data in EPSG:4326 (lat, lon). elevation optional (m)
// layers array top->down, thickness in meters, color
const boreholes = [
  { id:'BH-01', lat:50.1109, lon:8.6821, elevation:120, layers:[{thickness:2,color:0x8B4513},{thickness:3,color:0xDEB887},{thickness:1.5,color:0x808080}]},
  { id:'BH-02', lat:50.1115, lon:8.6835, elevation:121, layers:[{thickness:1.5,color:0x8B4513},{thickness:4,color:0xDAA520},{thickness:2,color:0x2E8B57}]},
  { id:'BH-03', lat:50.1100, lon:8.6840, elevation:119, layers:[{thickness:3,color:0x8B4513},{thickness:2.5,color:0xC2B280}]},
  { id:'BH-04', lat:50.1107, lon:8.6810, elevation:122, layers:[{thickness:1,color:0x8B4513},{thickness:2.2,color:0xDAA520},{thickness:1.2,color:0xA9A9A9}]}
];

// reference point = centroid -> equirectangular approximation
const refLat = boreholes.reduce((s,b)=>s+b.lat,0)/boreholes.length;
const refLon = boreholes.reduce((s,b)=>s+b.lon,0)/boreholes.length;
const metersPerDegLat = 111320;
const metersPerDegLon = 111320 * Math.cos(refLat * Math.PI/180);

function latLonToXZ(lat, lon) {
  const x = (lon - refLon) * metersPerDegLon;
  const z = (lat - refLat) * metersPerDegLat;
  return { x, z };
}

// create stacked cylinders along Y (up) -- top is at Y=0 (ground)
function createBoreholeGroup(x, z, layers, radius=0.8) {
  const g = new THREE.Group();
  let currentDepth = 0;
  layers.forEach((layer, idx) => {
    const h = layer.thickness;
    const geom = new THREE.CylinderGeometry(radius, radius, h, 32);
    const mat = new THREE.MeshStandardMaterial({color: layer.color, roughness:0.8, metalness:0.1});
    const mesh = new THREE.Mesh(geom, mat);
    // Cylinder's height is along Y; place center at Y = - (currentDepth + h/2)
    mesh.position.set(x, -(currentDepth + h/2), z);
    mesh.userData = { layerIndex: idx, thickness: h, borehole: null };
    g.add(mesh);
    currentDepth += h;
  });
  // small marker at top
  const topMat = new THREE.MeshBasicMaterial({color:0x000000});
  const topSphere = new THREE.Mesh(new THREE.SphereGeometry(0.12,8,8), topMat);
  topSphere.position.set(x, 0.15, z);
  g.add(topSphere);
  return g;
}

// add boreholes to scene
boreholes.forEach(bh=>{
  const p = latLonToXZ(bh.lat, bh.lon);
  const grp = createBoreholeGroup(p.x, p.z, bh.layers);
  grp.name = bh.id;
  scene.add(grp);
});

// Axes helper (small)
const axes = new THREE.AxesHelper(5);
scene.add(axes);

// Orbit controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, -2, 0);
controls.update();

window.addEventListener('resize', onWindowResize,false);
function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// clicking a layer shows its thickness
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
window.addEventListener('pointerdown', (ev)=>{
  mouse.x = (ev.clientX / window.innerWidth) * 2 - 1;
  mouse.y = - (ev.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  // intersect all meshes
  const intersects = raycaster.intersectObjects(scene.children, true);
  if(intersects.length){
    const hit = intersects[0].object;
    if(hit.userData && hit.userData.thickness){
      const bh = hit.parent ? hit.parent.name || '' : '';
      alert(`${bh} — Schicht ${hit.userData.layerIndex+1}: Mächtigkeit ${hit.userData.thickness} m`);
    }
  }
});

function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>
