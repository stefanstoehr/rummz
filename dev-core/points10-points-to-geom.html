<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P10</title>
    <style>
        html, body {
          height: 100%;
          margin: 0;
          overflow: hidden;
          font-family: Verdana;
        }
        canvas {
          width: 100%;
          height: 100%;
          display: block;
        }

        #info{
          position: absolute;
          margin-left: 10px;
        }

        a{
          color: yellow;
          text-decoration: none;
        }
    </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/delaunator@5.0.0/delaunator.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/voronoi@1.0.0/rhill-voronoi-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.3/dat.gui.min.js"></script>
 
 <script>

    //SCENE-BASICS
    console.clear();
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(60, 1, 1, 1000);
    camera.position.set(0, 0, 200);
    const axesHelper = new THREE.AxesHelper( 5 );
    scene.add( axesHelper );
    var renderer = new THREE.WebGLRenderer({ antialias: true });
    var canvas = renderer.domElement;
    document.body.appendChild(canvas);
    var controls = new THREE.OrbitControls(camera, canvas);
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.setScalar(100);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 1));
    
    //TEST1
    const buildgeo = new THREE.BufferGeometry();
    const buildverts = new Float32Array( [
        0,    0, 0,// v0
      -10,  -10, 0,// v1 
       10,  -10, 0,// v3      
    ] );
    buildgeo.setAttribute( 'position', new THREE.BufferAttribute( buildverts, 3 ) );
    const buildmat = new THREE.MeshBasicMaterial( { color: "red" } );
    const buildmesh = new THREE.Mesh( buildgeo, buildmat );
    scene.add(buildmesh);
    //TEST

    //TEST2
    const buildgeom2 = new THREE.BufferGeometry();
    const buildgeom2verts = new Float32Array( [
      -10,   10,   0, 
      -10,  -10,   0,
       0,     0,   0,
       //0,     1.25, 0,
       //-5.83, 10, 0,            
    ] );
    buildgeom2.setAttribute( 'position', new THREE.BufferAttribute( buildgeom2verts, 3 ) );
    const buildgeom2mat = new THREE.MeshBasicMaterial( { color: "yellow" } );
    const buildgeom2mesh = new THREE.Mesh( buildgeom2, buildgeom2mat );
    scene.add(buildgeom2mesh);
    console.log(buildgeom2mesh);
    //TEST

    /////////////////////////////////////TEST3

// CALIFORNIA

const californiaPts = [];

californiaPts.push( new THREE.Vector2( -10, 10 ) );
californiaPts.push( new THREE.Vector2( -10, -10 ) );
californiaPts.push( new THREE.Vector2( 0, 0 ) );
californiaPts.push( new THREE.Vector2( 0, 1.25 ) );
californiaPts.push( new THREE.Vector2( -5.833333333333333, 10 ) );

const californiaShape = new THREE.Shape( californiaPts );
const brownGeometry = new THREE.ShapeGeometry( californiaShape );
const brownMesh = new THREE.Mesh( brownGeometry, new THREE.MeshPhongMaterial( { color: "brown", side: THREE.DoubleSide } ) );

scene.add(brownMesh)

////////////////////////////////////TEST3

    //POINT-INPUT FROM MAP
    var points2d = [];
    points2d.push( new THREE.Vector2( - 10, 0 ) );
    points2d.push( new THREE.Vector2( 0, -10 ) );
    points2d.push( new THREE.Vector2( 10, 0 ) );
    points2d.push( new THREE.Vector2( 5, 10 ) );

    //CREATING VISIBLE POINT-GEOMETRY FROM POINTS
    var geom = new THREE.BufferGeometry().setFromPoints(points2d);
    var cloud = new THREE.Points( geom, new THREE.PointsMaterial({ color: "cyan", size: 2 }));
    scene.add(cloud);

    //DELUNATOR//           
    var indexDelaunay = Delaunator.from(
        points2d.map(v => {
            return [v.x, v.y];
        })
    );
    var meshIndex = []; // delaunay index => three.js index
    for (let i = 0; i < indexDelaunay.triangles.length; i++){
        meshIndex.push(indexDelaunay.triangles[i]);
    };
    geom.setIndex(meshIndex); // add three.js index to the existing geometry
    geom.computeVertexNormals();
    var mesh = new THREE.Mesh(
        geom, // re-use the existing geometry
        new THREE.MeshLambertMaterial({ color: 0x99ccff, wireframe: true })
    );
    scene.add(mesh);

    //BOUNDING-BOX-HELPER
    const boxbox = new THREE.BoxHelper( mesh, 0xffff00 ); scene.add( boxbox );

    //CALCULATING VORONOI
    var voronoi = new Voronoi();
    var bbox = {xl: -10, xr: 10, yt: -10, yb: 10}; // Max.-/Min.-Search
    var diagram = voronoi.compute(points2d, bbox);
    
    //console.log(diagram.vertices)
    //console.log(diagram.cells[1].halfedges[0].edge.va.y)
    //while (i = 0, i < diagram.cells.length, i++) {
    console.log(diagram.cells[1].halfedges[4].getStartpoint());
    console.log(diagram.cells[1].halfedges[3].getStartpoint());
    console.log(diagram.cells[1].halfedges[2].getStartpoint());
    console.log(diagram.cells[1].halfedges[1].getStartpoint());
    console.log(diagram.cells[1].halfedges[0].getStartpoint());
    
    console.log(diagram.cells);
    //}

    //CREATING VISIBLE THREE.JS-POINT-GEOMETRY FROM VORONOIS-POINTS
    var voronoiPoints = diagram.vertices;
    var voronoiPointsGeom = new THREE.BufferGeometry().setFromPoints(voronoiPoints);
    var voronoiPointsMat = new THREE.PointsMaterial({color: "magenta", size: 2});
    var voronoiPoints = new THREE.Points(voronoiPointsGeom, voronoiPointsMat);
    scene.add(voronoiPoints);

    //CREATING THREE.JS-LINES FROM VORONOIS
    var voronoiLinesPoints = [];
    diagram.edges.forEach(ed => {
      voronoiLinesPoints.push(ed.va.x, ed.va.y, 0, ed.vb.x, ed.vb.y, 0)
    });
    var voronoiLinesGeom = new THREE.BufferGeometry();
    voronoiLinesGeom.setAttribute("position", new THREE.Float32BufferAttribute(voronoiLinesPoints, 3));
    var voronoiLinesMat = new THREE.LineBasicMaterial({color: "green"});
    var voronoiLines = new THREE.LineSegments(voronoiLinesGeom, voronoiLinesMat);
    scene.add(voronoiLines);

    //CREATING GUI
    var gui = new dat.GUI({width: 400});
    gui.add(axesHelper, "visible").name("axes helper");
    gui.add(cloud, "visible").name("base points");
    gui.add(boxbox, "visible").name("bounding box");
    gui.add(mesh, "visible").name("delauny triangles");
    gui.add(voronoiPoints, "visible").name("voronoi points");
    gui.add(voronoiLines, "visible").name("voronoi lines");

    //THREE.JS BASIC VISUAL FINISHING
    render();

    function resize(renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render() {
      if (resize(renderer)) {
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

</script>
</body>
</html>
