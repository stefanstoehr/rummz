<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P7</title>
    <style>
        html, body {
          height: 100%;
          margin: 0;
          overflow: hidden;
          font-family: Verdana;
        }
        canvas {
          width: 100%;
          height: 100%;
          display: block;
        }

        #info{
          position: absolute;
          margin-left: 10px;
        }

        a{
          color: yellow;
          text-decoration: none;
        }
    </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!--<script src="https://cdn.jsdelivr.net/npm/d3-delaunay@5.0.0/dist/d3-delaunay.min.js"></script>-->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/voronoi@1.0.0/rhill-voronoi-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.3/dat.gui.min.js"></script>
 
 <script>

    //SCENE-BASICS
    console.clear();
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(60, 1, 1, 1000);
    camera.position.set(0, 0, 200);
    const axesHelper = new THREE.AxesHelper( 5 ); scene.add( axesHelper );
    var renderer = new THREE.WebGLRenderer({ antialias: true });
    var canvas = renderer.domElement;
    document.body.appendChild(canvas);
    var controls = new THREE.OrbitControls(camera, canvas);
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.setScalar(100);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 1));

    //POINT-INPUT FROM MAP
    var points2d = [];
    points2d.push( new THREE.Vector2( - 10, 0 ) );
    points2d.push( new THREE.Vector2( 0, -10 ) );
    points2d.push( new THREE.Vector2( 10, 0 ) );
    points2d.push( new THREE.Vector2( 5, 10 ) );

    //CREATING VISIBLE POINT-GEOMETRY FROM POINTS
    var geom = new THREE.BufferGeometry().setFromPoints(points2d);
    var cloud = new THREE.Points( geom, new THREE.PointsMaterial({ color: "cyan", size: 2 }));
    scene.add(cloud);

    //CALCULATING VORONOI
    var voronoi = new Voronoi();
    var bbox = {xl: -10, xr: 10, yt: -10, yb: 10}; // Max.-/Min.-Search
    var diagram = voronoi.compute(points2d, bbox);
    console.log(diagram);

    //CREATING VISIBLE POINT-GEOMETRY FROM VORONOIS-POINTS
    var voronoiPoints = diagram.vertices;
    var voronoiPointsGeom = new THREE.BufferGeometry().setFromPoints(voronoiPoints);
    var voronoiPointsMat = new THREE.PointsMaterial({color: "magenta", size: 2});
    var voronoiPoints = new THREE.Points(voronoiPointsGeom, voronoiPointsMat);
    scene.add(voronoiPoints);

    //CREATING THREE.JS-LINES FROM VORONOIS
    var voronoiLinesPoints = [];
    diagram.edges.forEach(ed => {
      voronoiLinesPoints.push(ed.va.x, ed.va.y, 0, ed.vb.x, ed.vb.y, 0)
    });
    var voronoiLinesGeom = new THREE.BufferGeometry();
    voronoiLinesGeom.setAttribute("position", new THREE.Float32BufferAttribute(voronoiLinesPoints, 3));
    var voronoiLinesMat = new THREE.LineBasicMaterial({color: "green"});
    var voronoiLines = new THREE.LineSegments(voronoiLinesGeom, voronoiLinesMat);
    scene.add(voronoiLines);

    //CREATING GUI
    var gui = new dat.GUI({width: 400});
    gui.add(cloud, "visible").name("base points");
    gui.add(voronoiPoints, "visible").name("voronoi points");
    gui.add(voronoiLines, "visible").name("voronoi lines");

    //THREE.JS BASIC VISUAL FINISHING
    render();

    function resize(renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render() {
      if (resize(renderer)) {
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

</script>
</body>
</html>
